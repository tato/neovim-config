"‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ú‚†ò‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚†Ä‚†Å‚£ø‚¢≥‚†Å‚¢à‚¢∞‚°¶‚†à‚†Ä‚¢ª ‚†Ä‚†Ä‚†ò‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚°ú‚†Ä‚†Ä‚†Ä
"‚£ø‚£ø‚°è‚†Ä‚†Ä‚¢Ä‚£Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†à‚†â‚†Ä‚†Ä‚†Ä‚°ò‚†Ä‚¢∞‚†õ‚¢†‚£¥‚£Ñ‚£å ‚†Ä‚†Ä‚†Ä‚†ë‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ÄVIM‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°î‚†Å‚†Ä‚†Ä‚†Ä
"‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢†‚£†‚°Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†à‚£°‚†ª‚¢π‚¢ø ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†¢‚¢Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚†¥‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
"‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä‚°Ä‚£Ä‚£º‚£ü‚£ø‚¢µ‚£§‚£§‚£§‚£§‚£§‚£§‚£Ñ‚£Ä‚£Ä‚£†‚†Ä‚†¢‚£Ω ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†§‚†Ñ‚†í‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
"‚£ø‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ê‚£å‚¢ñ‚£∞‚†ä‚†Å‚¢∏‚£ø‚°ü‚†à‚†Ä‚¢æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚°Ñ‚¢∞‚¢∫ ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£Ä‚†Ñ‚†ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
"‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°Ä‚¢¥‚¢ñ‚£†‚££‚£¥‚£ø‚¢ø‚°á‚£à‚†ê‚¢∫‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ä‚¢†‚£∏
"‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£º‚£ø‚£ø‚£ø‚£ø‚°∑‚†ã‚†Ö‚†Ä‚°Ä‚¢º‚£ø‚†Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚£º‚£ø
"‚°ø‚†Å‚†∏‚£Ñ‚£¶‚°Ä‚†Ä‚¢°‚£ø‚£ø‚£ø‚£ø‚£è‚°§‚†Ñ‚†Ñ‚†Ä‚†Ä‚†à‚†â‚†Å‚†ò‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚¢∏‚£ø
"‚†á‚†Ä‚†Ä‚°π‚¢ø‚°è‚†Ä‚£æ‚£ø‚£ü‚†ã‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†é‚†â‚†â‚†â‚†õ‚£§‚£ø
"‚°Ü‚†Ä‚°Ä‚¢£‚¢à‚°ü‚††‚†ª‚£ø‚£ø‚£∑‚°Ñ‚†Ä‚†Ä‚¢∏‚£∂‚£∑‚£∑‚£ß‚°Ñ‚†Ä‚†Ä‚¢ø‚£ß‚¢Ä‚°Ä‚†Ä‚†â‚¢°‚£ø‚£ø
"‚£ø‚£¶‚°Ä‚†ò‚¢º‚†É‚£†‚°≤‚†õ‚¢ø‚°ø‚£ø‚°Ä‚°Ä‚†Ä‚†π‚£ø‚£ø‚°ü‚†Ä‚††‚£§‚†ò‚£ø‚£∂‚£ø‚£∂‚°æ‚£≥‚£ø‚£ø
"‚£ø‚°ø‚£ø‚£∂‚°å‚†∞‚°Ö‚†å‚††‚†à‚†à‚†ô‚¢ô‚†ë‚¢∞‚†Ä‚†®‚†ü‚†Ä‚†Ä‚£¥‚¢å‚°Ö‚¢ª‚£ø‚£ø‚£ø‚°á‚£ø‚£ø‚£ø
"‚£ø‚¢á‚£ø‚£ø‚†£‚¢ø‚£Æ‚†Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†à‚†Å‚£∂‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚¢°‚£∫‚£ø‚£ø‚°ø‚£∏‚£ø‚£ø‚£ø
"‚£ø‚£æ‚£ø‚£è‚†ê‚£ø‚¢ü‚°à‚†Ç‚†Ä‚††‚†Ä‚†Ä‚†Ä‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£¢‚£º‚£∏‚£ø‚°ø‚¢à‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚£ø‚†É‚°Ä‚†à‚†ë‚†Å‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ä‚†≤‚†Ä‚†Ä‚†Ñ‚£Ä‚†Ä‚£∏‚£∑‚£Æ‚£ç‚†É‚¢π‚†á‚£ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚£ø‚¢Ä‚£æ‚£∑‚£∂‚£å‚†Ä‚††‚†Ä‚†Ä‚¢Ä‚†ç‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Å‚†à‚†ô‚†ã‚¢∞‚°ù‚£º‚£ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚£ø‚†ã‚†Ä‚£º‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚°Ä‚¢Ä‚£º‚¢£‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚£Ø‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°ü‚†õ‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†å‚†ì‚°Ä‚¢∞‚£Æ‚£æ‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚£ß‚†Ä‚£π‚£ø‚£ø‚£ø‚†ó‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚°Ä‚†Ä‚†à‚†Ä‚†Ä‚†à‚†ù‚£°‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚°è‚†Ä‚£ø‚£ø‚£ø‚†ø‚†É‚¢Ä‚£¥‚£∂‚£æ‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚¢†‚£∂‚£æ‚£Æ‚£ô‚°ª‚£ø‚¢ø‚£ø‚£ø‚£ø‚£ø
"‚£ø‚£ø‚°á‚†Ä‚£ø‚£ø‚†É‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚°º‚†ø‚£ø‚£ø‚£ø‚£ø‚£Æ‚°ë‚°ù‚£ø‚£ø‚£ø

" try to set english language for the editor. it is usually spanish by default
" on my systems, which is annoying when comparing certain error messages and
" such. in theory this could fail, but i would be surprised if it does.
silent! language en_US
silent! language en_US.utf-8

" set mapleader before anything else. if any plugin defines a <Leader> mapping
" while mapleader isn't set, it would use the default value of \. usually i
" don't want plugins to set mappings by default, but just in case.
let mapleader = " "


call plug#begin(stdpath("data") . "/plugged")
Plug 'neovim/nvim-lspconfig'
Plug 'ms-jpq/coq_nvim', {'branch': 'coq'}

Plug 'cespare/vim-toml'
Plug 'ziglang/zig.vim'
Plug 'beyondmarc/glsl.vim'

Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-treesitter/nvim-treesitter'
Plug 'nvim-telescope/telescope.nvim'

Plug 'lewis6991/gitsigns.nvim'
Plug 'feline-nvim/feline.nvim'
Plug 'mhinz/vim-startify'
call plug#end()

set fileformats=unix,dos
set hidden undofile
set clipboard+=unnamedplus
set tabstop=4 shiftwidth=4 expandtab
set ignorecase smartcase
set scrolloff=5
set title cursorline number relativenumber showmatch noruler
set linebreak
set noswapfile
set formatoptions-=t formatoptions+=croj textwidth=79
set termguicolors
set inccommand=nosplit

inoremap jk <ESC>
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap ; :
xnoremap ; :
nnoremap : ;
xnoremap : ;
nnoremap <C-s> :wa<CR>
map Y y$
nnoremap gV `[v`]
nnoremap Q :let<Space>@q=''<Left><C-R><C-R>q

lua << EOF
    local lspconfig = require("lspconfig")
    local coq = require("coq")
    vim.g.coq_settings = { clients = { snippets = { warn = {} } } }

    -- Mappings.
    -- See `:help vim.diagnostic.*` for documentation on any of the below functions
    local map = vim.api.nvim_set_keymap
    local opts = { noremap=true, silent=true }
    map('n', '<space>e', '<cmd>lua vim.diagnostic.open_float()<CR>', opts)
    map('n', '[d', '<cmd>lua vim.diagnostic.goto_prev()<CR>', opts)
    map('n', ']d', '<cmd>lua vim.diagnostic.goto_next()<CR>', opts)
    -- map('n', '<space>q', '<cmd>lua vim.diagnostic.setloclist()<CR>', opts)

    local on_attach = function(client, bufnr)
      -- Enable completion triggered by <c-x><c-o>
      -- vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

      -- Mappings.
      -- See `:help vim.lsp.*` for documentation on any of the below functions
      local bufmap = vim.api.nvim_buf_set_keymap
      bufmap(bufnr, 'n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
      bufmap(bufnr, 'n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
      bufmap(bufnr, 'n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
      bufmap(bufnr, 'n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
      bufmap(bufnr, 'n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
      -- bufmap(bufnr, 'n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
      -- bufmap(bufnr, 'n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
      -- bufmap(bufnr, 'n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
      bufmap(bufnr, 'n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
      bufmap(bufnr, 'n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
      -- bufmap(bufnr, 'n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
      bufmap(bufnr, 'n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
      bufmap(bufnr, 'n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
    end

    local servers = { "zls" }
    for _, lsp in pairs(servers) do
        lspconfig[lsp].setup(coq.lsp_ensure_capabilities{ on_attach = on_attach, })
    end
EOF

COQnow -s

lua << EOF
    require("gitsigns").setup { signcolumn = false }

    local feline = require("feline")
    local vi_mode_utils = require("feline.providers.vi_mode")

    local mode_hl = function (fg)
        return function() 
            if fg == "white" then fg = "black" end
            return {
                name = vi_mode_utils.get_mode_highlight_name(),
                fg = fg,
                -- bg = vi_mode_utils.get_mode_color(),
                bg = "white",
                style = "bold",
            }
        end
    end
    
    local components = { active = {}, inactive = {} }
    components.active[1] = {
        {
            provider = "‚ñä ",
            hl = mode_hl("skyblue"),
        },
        {
            provider = "vi_mode",
            hl = mode_hl("white"),
            right_sep = { str = " ", hl = mode_hl("white") },
            icon = "",
        },
        {
            provider = "file_info",
            hl = { fg = "white", bg = "oceanblue", style = "bold" },
            left_sep = { str = " ", hl = { bg = "oceanblue" } },
            right_sep = { str = " ", hl = { bg = "oceanblue", } },
            icon = "",
        },
        {
            provider = "file_size",
            left_sep = " ",
            right_sep = {
                " ",
                { str = "vertical_bar_thin", hl = { fg = "fg", bg = "bg" } },
            },
        },
        {
            provider = "position",
            left_sep = " ",
            right_sep = {
                " ",
                { str = "vertical_bar_thin", hl = { fg = "fg", bg = "bg" } },
            },
        },
        {
            provider = "diagnostic_errors",
            hl = { fg = "red" },
            icon = "ü•µ",
        },
        {
            provider = "diagnostic_warnings",
            hl = { fg = "yellow" },
            icon = "üòÖ",
        },
    }

    components.active[2] = {
        {
            provider = "git_branch",
            hl = { style = "bold" },
            left_sep = {
                { str = "vertical_bar_thin", hl = { fg = "fg", bg = "bg" } },
            },
            icon = " ",
        },
        {
            provider = "git_diff_added",
            icon = " +",
        },
        {
            provider = "git_diff_changed",
            icon = " ~",
        },
        {
            provider = "git_diff_removed",
            right_sep = {
                " ",
                { str = "vertical_bar_thin", hl = { fg = "fg", bg = "bg" } },
            },
            icon = " -",
        },
        {
            provider = "line_percentage",
            hl = { style = "bold" },
            left_sep = " ",
            right_sep = " ",
        },
        {
            provider = "scroll_bar",
            hl = { fg = "skyblue", style = "bold" },
        },
    }

    components.inactive[1] = {
        {
            provider = "file_info",
            icon = "",
            hl = { fg = "white", bg = "oceanblue", style = "bold" },
            left_sep = { str = " ", hl = { fg = "NONE", bg = "oceanblue" } },
            right_sep = {
                { str = " ", hl = { fg = "NONE", bg = "oceanblue" } },
                " ",
            },
        },
        -- Empty component to fix the highlight till the end of the statusline
        {},
    }


    local supok_theme = {
        bg = "#dad6ff",
        fg = "#25242b",
        black = "#1B1B1B",
        skyblue = "#9c86f9",
        cyan = "#009090",
        green = "#051c00",
        oceanblue = "#7c5ffc", -- primary_color
        magenta = "#C26BDB",
        orange = "#FF9000",
        red = "#D10000",
        violet = "#9E93E8",
        white = "#FFFFFF",
        yellow = "#E1E120",
    }

    feline.setup({
        components = components,
        theme = supok_theme,
    });
EOF

let g:startify_files_number = 5
let g:startify_bookmarks = [ { "c": "~/.config/nvim" }, { "l": "C:/code/land" } ]
let g:startify_commands = [ ]
let g:startify_custom_header = startify#pad(readfile(stdpath("config") . "/banner.txt"))

lua << EOF
    require("telescope").setup {
    }
EOF
nnoremap <C-p> <cmd>lua require('telescope.builtin').find_files()<cr>
nnoremap <leader>fg <cmd>lua require('telescope.builtin').live_grep()<cr>
nnoremap <leader>fb <cmd>lua require('telescope.builtin').buffers()<cr>
nnoremap <leader>fh <cmd>lua require('telescope.builtin').help_tags()<cr>

" lua require("colors")
" lua require("statusline")
colorscheme supok


" <leader>h/j/k/l: move to window in a direction. if it doesn't
" exist, create it.
nnoremap <silent> <leader>h :lua require('config').move('h')<CR>
nnoremap <silent> <leader>j :lua require('config').move('j')<CR>
nnoremap <silent> <leader>k :lua require('config').move('k')<CR>
nnoremap <silent> <leader>l :lua require('config').move('l')<CR>
" <leader>H/J/K/L: move window to a direction
nnoremap <silent> <leader>H <C-w>H
nnoremap <silent> <leader>J <C-w>J
nnoremap <silent> <leader>K <C-w>K
nnoremap <silent> <leader>L <C-w>L
" <leader>q: close window
nnoremap <silent> <leader>q :close<CR>


nnoremap <silent> <leader>fed :e $MYVIMRC<CR>
nnoremap <silent> <leader>fsd :source $MYVIMRC<CR> | nohlsearch

function! TheBigReset()
    nohlsearch
    diffupdate
    cclose
    mode
endfunction
nnoremap <silent> <C-l> <Cmd>call TheBigReset()<CR>

" nnoremap <silent> <C-.> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" nnoremap gb :ls<CR>:buffer<Space>
" nnoremap <leader>b :buffer *

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid, when inside an event handler
" (happens when dropping a file on gvim) and for a commit message (it's
" likely a different one than last time).
augroup last_position_jump
    autocmd!
    au BufReadPost *
        \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |     exe "normal! g`\""
        \ | endif
augroup END

" When writing a search query in the command line, but before committing
" to that search, use Tab to go to the next match and Shift-Tab to go to the
" previous match
" set wildcharm=<C-z>
" cnoremap <expr> <Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-g>" : "<C-z>"
" cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-t>" : "<S-Tab>"

" echo the names of the highlighting groups applied to the character under the
" cursor. The names may be linked to a more general group, which isn't shown.
nnoremap <leader>i :call <SID>SynStack()<CR>
function! <SID>SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunction
