"⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡜⠘⠀⠀⠀⠀⠈⣿⠀⠁⣿⢳⠁⢈⢰⡦⠈⠀⢻ ⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⡜⠀⠀⠀
"⣿⣿⡏⠀⠀⢀⣀⠀⠀⡀⠀⠀⢀⠀⠀⠁⠀⠀⠈⠉⠀⠀⠀⡘⠀⢰⠛⢠⣴⣄⣌ ⠀⠀⠀⠑⡀⠀⠀⠀⠀⠀⠀⠀⠀VIM⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀
"⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢠⣠⡀⠀⠀⠀⠂⠀⠀⠀⠐⠀⠈⣡⠻⢹⢿ ⠀⠀⠀⠀⠈⠢⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠴⠊⠀⠀⠀⠀⠀
"⣿⣿⠀⠀⠀⠁⠀⠀⠀⠄⠀⠀⡀⣀⣼⣟⣿⢵⣤⣤⣤⣤⣤⣤⣄⣀⣀⣠⠀⠢⣽ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠤⠄⠒⠈⠀⠀⠀⠀⠀⠀⠀⠀
"⣿⡿⠀⠀⠀⠀⠀⢐⣌⢖⣰⠊⠁⢸⣿⡟⠈⠀⢾⣿⣿⣿⣿⣿⣿⣿⣿⣾⡄⢰⢺ ⠀⠀⠀⠀⠀⠀⠀⠘⣀⠄⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
"⣿⡇⠀⠀⠀⠀⢀⡀⢴⢖⣠⣣⣴⣿⢿⡇⣈⠐⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢠⣸
"⣿⣷⡀⠀⠀⠀⠀⠸⣼⣿⣿⣿⣿⡷⠋⠅⠀⡀⢼⣿⠯⣿⣿⣿⣿⣿⣿⣿⡇⣼⣿
"⡿⠁⠸⣄⣦⡀⠀⢡⣿⣿⣿⣿⣏⡤⠄⠄⠀⠀⠈⠉⠁⠘⢿⣿⣿⣿⣿⣿⣯⢸⣿
"⠇⠀⠀⡹⢿⡏⠀⣾⣿⣟⠋⠉⠁⠀⠀⠀⠀⣀⣀⠀⠀⠀⢸⣿⠎⠉⠉⠉⠛⣤⣿
"⡆⠀⡀⢣⢈⡟⠠⠻⣿⣿⣷⡄⠀⠀⢸⣶⣷⣷⣧⡄⠀⠀⢿⣧⢀⡀⠀⠉⢡⣿⣿
"⣿⣦⡀⠘⢼⠃⣠⡲⠛⢿⡿⣿⡀⡀⠀⠹⣿⣿⡟⠀⠠⣤⠘⣿⣶⣿⣶⡾⣳⣿⣿
"⣿⡿⣿⣶⡌⠰⡅⠌⠠⠈⠈⠙⢙⠑⢰⠀⠨⠟⠀⠀⣴⢌⡅⢻⣿⣿⣿⡇⣿⣿⣿
"⣿⢇⣿⣿⠣⢿⣮⠀⢀⡀⠀⠀⠈⠁⣶⠀⠀⠀⠀⠀⠁⠀⢡⣺⣿⣿⡿⣸⣿⣿⣿
"⣿⣾⣿⣏⠐⣿⢟⡈⠂⠀⠠⠀⠀⠀⣆⠀⠀⠀⠀⠀⠀⣢⣼⣸⣿⡿⢈⣿⣿⣿⣿
"⣿⣿⣿⠃⡀⠈⠑⠁⠀⠄⠀⠀⠀⠲⠀⠀⠄⣀⠀⣸⣷⣮⣍⠃⢹⠇⣿⣿⣿⣿⣿
"⣿⣿⣿⢀⣾⣷⣶⣌⠀⠠⠀⠀⢀⠍⠀⠀⠀⠀⠉⠁⠈⠙⠋⢰⡝⣼⣿⣿⣿⣿⣿
"⣿⣿⣿⠋⠀⣼⣿⣿⣷⣄⠀⠀⠀⠊⠀⠀⠀⠀⠀⠀⠄⡀⢀⣼⢣⣿⣿⣿⣿⣿⣿
"⣿⣿⣯⠀⢸⣿⣿⣿⡟⠛⠳⣄⠀⠀⠀⠀⠘⠌⠓⡀⢰⣮⣾⢠⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⣧⠀⣹⣿⣿⣿⠗⠀⠀⠀⠀⠀⣀⡀⠀⠈⠀⠀⠈⠝⣡⣾⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⡏⠀⣿⣿⣿⠿⠃⢀⣴⣶⣾⣿⣿⣿⣿⣷⣾⢠⣶⣾⣮⣙⡻⣿⢿⣿⣿⣿⣿
"⣿⣿⡇⠀⣿⣿⠃⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡟⡼⠿⣿⣿⣿⣿⣮⡑⡝⣿⣿⣿

" set english language for the editor. it is usually spanish by default on my
" systems, which is annoying when comparing certain error messages and such. in
" theory this could fail, but i would be surprised if it does.
silent! language en_US
silent! language en_US.utf-8

" set mapleader before any other config. if any plugin defines a <Leader>
" mapping while mapleader isn't set, it would use the default value of \.
" usually i don't want plugins to set mappings by default, but just in case.
let mapleader = " "

call plug#begin(stdpath("data") . "/plugged")
Plug 'rktjmp/lush.nvim'
Plug 'ziglang/zig.vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-vinegar'
Plug 'neovim/nvim-lspconfig'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'echasnovski/mini.nvim', { 'branch': 'stable' }
Plug 'folke/which-key.nvim'
call plug#end()

lua require "telescope".setup(require "plugin_config.telescope")
lua require "mini.starter".setup(require "plugin_config.mini_starter")
lua require "mini.tabline".setup(require "plugin_config.mini_tabline")
lua require "mini.statusline".setup(require "plugin_config.mini_statusline")
lua require "lspconfig"["zls"].setup { on_attach = require "plugin_config.lspconfig".on_attach }
lua require "which-key".setup(require "plugin_config.which_key")

set hidden undofile
set clipboard+=unnamedplus
set tabstop=4 shiftwidth=4 expandtab
set ignorecase smartcase
set scrolloff=5
set title cursorline number relativenumber showmatch noruler
set formatoptions-=tc formatoptions+=rojq textwidth=79 " reminder: i_CTRL-U
set termguicolors
set inccommand=nosplit
set linebreak breakindent
let &showbreak = "→   "

" When opening a file for editing, assume unix line endings always. If vim
" opens a file with dos line endings in this manner, it will show ^M at the end
" of each line, which is a very obvious sign that something is wrong.
"
" Some help buffers have dos line endings on Windows for some reason, and they
" throw an error when opened because vim can't parse the modeline. Allow help
" buffers to be opened with dos line endings to avoid that error.
set fileformats=unix
augroup line_endings_dont_matter_in_help_buffers
    autocmd!
    au BufReadPre  *.txt if &buftype == "help" | set fileformats+=dos | end
    au BufReadPost *.txt set fileformats-=dos
augroup END

" I don't like swap files. I set swapfile by default so that vim doesn't choke
" on huge files. After opening a file, check if it's small enough (<256MiB) and
" set noswapfile locally.
set swapfile
augroup ignore_swapfile_for_small_files
    autocmd!
    au BufReadPost * if getfsize(expand("%")) < 256*1024*1024 | setlocal noswapfile | end
augroup END

augroup gui_conf
    autocmd!
    au UIEnter * set guifont=Iosevka\ Fixed:h18
augroup END
if exists(":GuiFont") 
    GuiFont! Iosevka\ Fixed:h18
    GuiTabline 1
    GuiPopupmenu 1
    GuiScrollBar 0
endif
if exists("g:neovide")
    let g:neovide_transparency=0.85
    let g:neovide_fullscreen=v:true
endif
set mouse=a
set background=dark
colorscheme nightlight

inoremap jk <ESC>
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
noremap H ^
noremap L $
noremap ; :
noremap : ;
nnoremap <C-s> :wa<CR>
nnoremap Q :q<CR>
noremap Y y$
nnoremap gV `[v`]
nnoremap gb <C-6>

" clear search highlighting, close quickfix window, reload display
nnoremap <silent> <C-l> :nohlsearch <bar> diffupdate <bar> cclose <bar> mode<CR>

" edit/source init.vim
nnoremap <silent> <leader>fed :e $MYVIMRC<CR>
nnoremap <silent> <leader>fsd :source $MYVIMRC<CR> | nohlsearch

" <leader>h/j/k/l: move to window in a direction. if it doesn't
" exist, create it.
nnoremap <silent> <leader>h :call bufmove#move('h')<CR>
nnoremap <silent> <leader>j :call bufmove#move('j')<CR>
nnoremap <silent> <leader>k :call bufmove#move('k')<CR>
nnoremap <silent> <leader>l :call bufmove#move('l')<CR>
" <leader>H/J/K/L: move window to a direction
nnoremap <silent> <leader>wh <C-w>H
nnoremap <silent> <leader>wj <C-w>J
nnoremap <silent> <leader>wk <C-w>K
nnoremap <silent> <leader>wl <C-w>L
" <leader>q: close window
nnoremap <silent> <leader>q :close<CR>

nnoremap <silent> <leader>bn :bn<CR>
nnoremap <silent> <leader>bd :lua require 'mini.bufremove'.delete()<CR>
nnoremap <silent> <leader>!bd :lua require 'mini.bufremove'.delete(0, true)<CR>

nnoremap zp <cmd>lua require 'telescope.builtin'.find_files()<cr>
nnoremap zz <cmd>lua require 'telescope.builtin'.builtin()<cr>
nnoremap zm <cmd>lua require 'telescope.builtin'.marks()<cr>

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid, when inside an event handler
" (happens when dropping a file on gvim) and for a commit message (it's
" likely a different one than last time).
augroup last_position_jump
    autocmd!
    au BufReadPost *
        \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |     exe "normal! g`\""
        \ | endif
augroup END

" echo the names of the highlighting groups applied to the character under the
" cursor. The names may be linked to a more general group, which isn't shown.
nnoremap <leader>i :call <SID>SynStack()<CR>
function! <SID>SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunction

" tested on my daily driver, neovim 0.7.0
