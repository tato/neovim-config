"⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⡜⠀⠀⠀
"⠀⠀⠀⠑⡀⠀⠀⠀⠀⠀⠀⠀⠀VIM⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀
"⠀⠀⠀⠀⠈⠢⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠴⠊⠀⠀⠀⠀⠀
"⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠤⠄⠒⠈⠀⠀⠀⠀⠀⠀⠀⠀
"⠀⠀⠀⠀⠀⠀⠀⠘⣀⠄⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
"⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡜⠘⠀⠀⠀⠀⠈⣿⠀⠁⣿⢳⠁⢈⢰⡦⠈⠀⢻
"⣿⣿⡏⠀⠀⢀⣀⠀⠀⡀⠀⠀⢀⠀⠀⠁⠀⠀⠈⠉⠀⠀⠀⡘⠀⢰⠛⢠⣴⣄⣌
"⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢠⣠⡀⠀⠀⠀⠂⠀⠀⠀⠐⠀⠈⣡⠻⢹⢿
"⣿⣿⠀⠀⠀⠁⠀⠀⠀⠄⠀⠀⡀⣀⣼⣟⣿⢵⣤⣤⣤⣤⣤⣤⣄⣀⣀⣠⠀⠢⣽
"⣿⡿⠀⠀⠀⠀⠀⢐⣌⢖⣰⠊⠁⢸⣿⡟⠈⠀⢾⣿⣿⣿⣿⣿⣿⣿⣿⣾⡄⢰⢺
"⣿⡇⠀⠀⠀⠀⢀⡀⢴⢖⣠⣣⣴⣿⢿⡇⣈⠐⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢠⣸
"⣿⣷⡀⠀⠀⠀⠀⠸⣼⣿⣿⣿⣿⡷⠋⠅⠀⡀⢼⣿⠯⣿⣿⣿⣿⣿⣿⣿⡇⣼⣿
"⡿⠁⠸⣄⣦⡀⠀⢡⣿⣿⣿⣿⣏⡤⠄⠄⠀⠀⠈⠉⠁⠘⢿⣿⣿⣿⣿⣿⣯⢸⣿
"⠇⠀⠀⡹⢿⡏⠀⣾⣿⣟⠋⠉⠁⠀⠀⠀⠀⣀⣀⠀⠀⠀⢸⣿⠎⠉⠉⠉⠛⣤⣿
"⡆⠀⡀⢣⢈⡟⠠⠻⣿⣿⣷⡄⠀⠀⢸⣶⣷⣷⣧⡄⠀⠀⢿⣧⢀⡀⠀⠉⢡⣿⣿
"⣿⣦⡀⠘⢼⠃⣠⡲⠛⢿⡿⣿⡀⡀⠀⠹⣿⣿⡟⠀⠠⣤⠘⣿⣶⣿⣶⡾⣳⣿⣿
"⣿⡿⣿⣶⡌⠰⡅⠌⠠⠈⠈⠙⢙⠑⢰⠀⠨⠟⠀⠀⣴⢌⡅⢻⣿⣿⣿⡇⣿⣿⣿
"⣿⢇⣿⣿⠣⢿⣮⠀⢀⡀⠀⠀⠈⠁⣶⠀⠀⠀⠀⠀⠁⠀⢡⣺⣿⣿⡿⣸⣿⣿⣿
"⣿⣾⣿⣏⠐⣿⢟⡈⠂⠀⠠⠀⠀⠀⣆⠀⠀⠀⠀⠀⠀⣢⣼⣸⣿⡿⢈⣿⣿⣿⣿
"⣿⣿⣿⠃⡀⠈⠑⠁⠀⠄⠀⠀⠀⠲⠀⠀⠄⣀⠀⣸⣷⣮⣍⠃⢹⠇⣿⣿⣿⣿⣿
"⣿⣿⣿⢀⣾⣷⣶⣌⠀⠠⠀⠀⢀⠍⠀⠀⠀⠀⠉⠁⠈⠙⠋⢰⡝⣼⣿⣿⣿⣿⣿
"⣿⣿⣿⠋⠀⣼⣿⣿⣷⣄⠀⠀⠀⠊⠀⠀⠀⠀⠀⠀⠄⡀⢀⣼⢣⣿⣿⣿⣿⣿⣿
"⣿⣿⣯⠀⢸⣿⣿⣿⡟⠛⠳⣄⠀⠀⠀⠀⠘⠌⠓⡀⢰⣮⣾⢠⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⣧⠀⣹⣿⣿⣿⠗⠀⠀⠀⠀⠀⣀⡀⠀⠈⠀⠀⠈⠝⣡⣾⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⡏⠀⣿⣿⣿⠿⠃⢀⣴⣶⣾⣿⣿⣿⣿⣷⣾⢠⣶⣾⣮⣙⡻⣿⢿⣿⣿⣿⣿
"⣿⣿⡇⠀⣿⣿⠃⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡟⡼⠿⣿⣿⣿⣿⣮⡑⡝⣿⣿⣿

" GONEOVIM BUGS;
" - DON'T SHOW COMMAND BOX WHEN COMMAND IS RESULT OF A KEYBINDING
" - WHEN CURSOR IS DOUBLE SIZE AND YOU MOVE TO THE COMMAND BOX, CURSOR IS
"   DOUBLE SIZE THERE TOO

set fileformats=unix,dos
set hidden
set clipboard+=unnamedplus
set tabstop=4 shiftwidth=4 expandtab
set ignorecase smartcase
set scrolloff=5
set title
set cursorline
set number
set showmatch
set linebreak
set noswapfile

call plug#begin(stdpath('data') . '/plugged')
Plug 'gruvbox-community/gruvbox'
Plug 'romainl/flattened'
Plug 'huyvohcmc/atlas.vim'

Plug 'cespare/vim-toml'

Plug 'liuchengxu/vim-which-key'
Plug 'hoob3rt/lualine.nvim'
Plug 'thirtythreeforty/lessspace.vim'

Plug 'mhinz/vim-startify'
" Plug 'kyazdani42/nvim-web-devicons'
" Plug 'jiangmiao/auto-pairs'
" fzf
" startup
" ?editorconfig?
" projects
call plug#end()

nnoremap <Space> <Nop>
let mapleader = " "

call which_key#register("<Space>", "g:which_key_map")
nnoremap <silent> <leader> :<c-u>WhichKey "<Space>"<CR>
let g:which_key_map = {}

" TODO: nnoremap (??) :Startify
let g:startify_bookmarks = [ '~/.config/nvim' ]
let g:startify_custom_header = startify#pad(readfile(stdpath("config") . "/banner.txt"))

call supok#configure_gruvbox()


inoremap jk <ESC>
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap ; :
nnoremap : ;
nnoremap <C-s> :wa<CR>
map Y y$
nnoremap gV `[v`]
nnoremap Q :let<Space>@q=''<Left><C-R><C-R>q
nnoremap <silent> <C-.> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>


let g:which_key_map.w = { "name": "+window" }
call supok#mapping("wh", ":call supok#move('h')<CR>", "go / create win left")
call supok#mapping("wj", ":call supok#move('j')<CR>", "go / create win down")
call supok#mapping("wk", ":call supok#move('k')<CR>", "go / create win up")
call supok#mapping("wl", ":call supok#move('l')<CR>", "go / create win right")
let g:which_key_map.w.w = { 'name': '+move windows' }
call supok#mapping("wwh", "<C-w>H", "move win left")
call supok#mapping("wwj", "<C-w>J", "move win down")
call supok#mapping("wwk", "<C-w>K", "move win up")
call supok#mapping("wwl", "<C-w>L", "move win right")
call supok#mapping("wq", ":close<CR>", "close win")

let g:which_key_map.f = { "name": "+file" }
let g:which_key_map.f.e = { "name": "+edit file" }
let g:which_key_map.f.s = { "name": "+source file" }
call supok#mapping("fed", ":e $MYVIMRC<CR>", "edit init.vim")
call supok#mapping("feg", ":e ~/.goneovim/settings.toml<CR>", "edit goneovim settings")
call supok#mapping("fsd", ":source $MYVIMRC<CR> | nohlsearch", "source / refresh init.vim")

" nnoremap gb :ls<CR>:buffer<Space>
" nnoremap <leader>b :buffer *

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid, when inside an event handler
" (happens when dropping a file on gvim) and for a commit message (it's
" likely a different one than last time).
augroup last_position_jump
    autocmd!
    au BufReadPost *
        \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |     exe "normal! g`\""
        \ | endif
augroup END

" When writing a search query in the command line, but before committing
" to that search, use Tab to go to the next match and Shift-Tab to go to the
" previous match
set wildcharm=<C-z>
cnoremap <expr> <Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-g>" : "<C-z>"
cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-t>" : "<S-Tab>"

" when I'm writing a comment and that comment exceeds a certain column
" (currently it is configured as 79), break the line (using word
" boundaries) and continue writing the comment on the following line
augroup adjust_comment_line_length
    autocmd!
    au TextChanged,TextChangedI * :call supok#adjust_comment_line_length()
augroup END
