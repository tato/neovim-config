"⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡜⠘⠀⠀⠀⠀⠈⣿⠀⠁⣿⢳⠁⢈⢰⡦⠈⠀⢻ ⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⡜⠀⠀⠀
"⣿⣿⡏⠀⠀⢀⣀⠀⠀⡀⠀⠀⢀⠀⠀⠁⠀⠀⠈⠉⠀⠀⠀⡘⠀⢰⠛⢠⣴⣄⣌ ⠀⠀⠀⠑⡀⠀⠀⠀⠀⠀⠀⠀⠀VIM⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀
"⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢠⣠⡀⠀⠀⠀⠂⠀⠀⠀⠐⠀⠈⣡⠻⢹⢿ ⠀⠀⠀⠀⠈⠢⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠴⠊⠀⠀⠀⠀⠀
"⣿⣿⠀⠀⠀⠁⠀⠀⠀⠄⠀⠀⡀⣀⣼⣟⣿⢵⣤⣤⣤⣤⣤⣤⣄⣀⣀⣠⠀⠢⣽ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠤⠄⠒⠈⠀⠀⠀⠀⠀⠀⠀⠀
"⣿⡿⠀⠀⠀⠀⠀⢐⣌⢖⣰⠊⠁⢸⣿⡟⠈⠀⢾⣿⣿⣿⣿⣿⣿⣿⣿⣾⡄⢰⢺ ⠀⠀⠀⠀⠀⠀⠀⠘⣀⠄⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
"⣿⡇⠀⠀⠀⠀⢀⡀⢴⢖⣠⣣⣴⣿⢿⡇⣈⠐⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢠⣸
"⣿⣷⡀⠀⠀⠀⠀⠸⣼⣿⣿⣿⣿⡷⠋⠅⠀⡀⢼⣿⠯⣿⣿⣿⣿⣿⣿⣿⡇⣼⣿
"⡿⠁⠸⣄⣦⡀⠀⢡⣿⣿⣿⣿⣏⡤⠄⠄⠀⠀⠈⠉⠁⠘⢿⣿⣿⣿⣿⣿⣯⢸⣿
"⠇⠀⠀⡹⢿⡏⠀⣾⣿⣟⠋⠉⠁⠀⠀⠀⠀⣀⣀⠀⠀⠀⢸⣿⠎⠉⠉⠉⠛⣤⣿
"⡆⠀⡀⢣⢈⡟⠠⠻⣿⣿⣷⡄⠀⠀⢸⣶⣷⣷⣧⡄⠀⠀⢿⣧⢀⡀⠀⠉⢡⣿⣿
"⣿⣦⡀⠘⢼⠃⣠⡲⠛⢿⡿⣿⡀⡀⠀⠹⣿⣿⡟⠀⠠⣤⠘⣿⣶⣿⣶⡾⣳⣿⣿
"⣿⡿⣿⣶⡌⠰⡅⠌⠠⠈⠈⠙⢙⠑⢰⠀⠨⠟⠀⠀⣴⢌⡅⢻⣿⣿⣿⡇⣿⣿⣿
"⣿⢇⣿⣿⠣⢿⣮⠀⢀⡀⠀⠀⠈⠁⣶⠀⠀⠀⠀⠀⠁⠀⢡⣺⣿⣿⡿⣸⣿⣿⣿
"⣿⣾⣿⣏⠐⣿⢟⡈⠂⠀⠠⠀⠀⠀⣆⠀⠀⠀⠀⠀⠀⣢⣼⣸⣿⡿⢈⣿⣿⣿⣿
"⣿⣿⣿⠃⡀⠈⠑⠁⠀⠄⠀⠀⠀⠲⠀⠀⠄⣀⠀⣸⣷⣮⣍⠃⢹⠇⣿⣿⣿⣿⣿
"⣿⣿⣿⢀⣾⣷⣶⣌⠀⠠⠀⠀⢀⠍⠀⠀⠀⠀⠉⠁⠈⠙⠋⢰⡝⣼⣿⣿⣿⣿⣿
"⣿⣿⣿⠋⠀⣼⣿⣿⣷⣄⠀⠀⠀⠊⠀⠀⠀⠀⠀⠀⠄⡀⢀⣼⢣⣿⣿⣿⣿⣿⣿
"⣿⣿⣯⠀⢸⣿⣿⣿⡟⠛⠳⣄⠀⠀⠀⠀⠘⠌⠓⡀⢰⣮⣾⢠⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⣧⠀⣹⣿⣿⣿⠗⠀⠀⠀⠀⠀⣀⡀⠀⠈⠀⠀⠈⠝⣡⣾⣿⣿⣿⣿⣿⣿⣿
"⣿⣿⡏⠀⣿⣿⣿⠿⠃⢀⣴⣶⣾⣿⣿⣿⣿⣷⣾⢠⣶⣾⣮⣙⡻⣿⢿⣿⣿⣿⣿
"⣿⣿⡇⠀⣿⣿⠃⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡟⡼⠿⣿⣿⣿⣿⣮⡑⡝⣿⣿⣿

silent! language en_US
silent! language en_US.utf-8

nnoremap <Space> <Nop>
let mapleader = " "

call plug#begin(stdpath("data") . "/plugged")
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-treesitter/nvim-treesitter'
Plug 'gruvbox-community/gruvbox'
Plug 'cespare/vim-toml'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'kyazdani42/nvim-web-devicons'
Plug 'glepnir/galaxyline.nvim'
Plug 'mhinz/vim-startify'
Plug 'liuchengxu/vim-which-key'
Plug 'vimwiki/vimwiki'
Plug 'nvim-telescope/telescope.nvim'

" Plug 'jiangmiao/auto-pairs'
" ?editorconfig?
" projects
call plug#end()

set fileformats=unix,dos
set hidden undofile
set clipboard+=unnamedplus
set tabstop=4 shiftwidth=4 expandtab
set ignorecase smartcase
set scrolloff=5
set title cursorline number showmatch noruler
set linebreak
set noswapfile
set formatoptions-=t formatoptions+=croj textwidth=79
set termguicolors
set inccommand=nosplit

inoremap jk <ESC>
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap ; :
xnoremap ; :
nnoremap : ;
xnoremap : ;
nnoremap <C-s> :wa<CR>
map Y y$
nnoremap gV `[v`]
nnoremap Q :let<Space>@q=''<Left><C-R><C-R>q


call which_key#register("<Space>", "g:which_key_map")
nnoremap <silent> <leader> :<c-u>WhichKey "<Space>"<CR>
let g:which_key_map = {}

let g:gitgutter_signs = 0
let g:gitgutter_map_keys = 0

lua << EOF
    require("telescope").setup {
    }
EOF

lua require("colors")
lua require("statusline")

let g:startify_files_number = 5
let g:startify_bookmarks = [ { "c": "~/.config/nvim" }, { "w": "D:/monky garden" } ]
let g:startify_commands = [ { "o": [ "Open Vimwiki on monky garden", "echom haha" ] } ]
let g:startify_custom_header = startify#pad(readfile(stdpath("config") . "/banner.txt"))

let g:vimwiki_list = [{"path": "D:/monky garden", "path_html": "D:/monky garden html"}]
" let g:vimwiki_key_mappings = { "all_maps": 0, }

lua require("config").configure_gruvbox()

lua << EOF
local cfg = require("config")
cfg.mapping("h", ":lua require('config').move('h')<CR>", "go / create win left")
cfg.mapping("j", ":lua require('config').move('j')<CR>", "go / create win down")
cfg.mapping("k", ":lua require('config').move('k')<CR>", "go / create win up")
cfg.mapping("l", ":lua require('config').move('l')<CR>", "go / create win right")
cfg.mapping("H", "<C-w>H", "move win left")
cfg.mapping("J", "<C-w>J", "move win down")
cfg.mapping("K", "<C-w>K", "move win up")
cfg.mapping("L", "<C-w>L", "move win right")
cfg.mapping("q", ":close<CR>", "close win")
EOF

let g:which_key_map.f = { "name": "+file" }
let g:which_key_map.f.e = { "name": "+edit file" }
let g:which_key_map.f.s = { "name": "+source file" }
lua << EOF
local cfg = require("config")
cfg.mapping("fed", ":e $MYVIMRC<CR>", "edit init.vim")
cfg.mapping("feg", ":e ~/.goneovim/settings.toml<CR>", "edit goneovim settings")
cfg.mapping("fsd", ":source $MYVIMRC<CR> | nohlsearch", "source / refresh init.vim")
EOF

" nnoremap <silent> <C-.> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" nnoremap gb :ls<CR>:buffer<Space>
" nnoremap <leader>b :buffer *

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid, when inside an event handler
" (happens when dropping a file on gvim) and for a commit message (it's
" likely a different one than last time).
augroup last_position_jump
    autocmd!
    au BufReadPost *
        \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |     exe "normal! g`\""
        \ | endif
augroup END

" When writing a search query in the command line, but before committing
" to that search, use Tab to go to the next match and Shift-Tab to go to the
" previous match
set wildcharm=<C-z>
cnoremap <expr> <Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-g>" : "<C-z>"
cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<C-t>" : "<S-Tab>"

set guifont=FiraCode\ NF:h16,Fira\ Code:h16,Cousine:h16

" " Custom Text Objects {{{
" " https://gist.github.com/romainl/c0a8b57a36aec71a986f1120e1931f20
"
" " 24 simple text-objects
" " ----------------------
" " i_ i. i: i, i; i| i/ i\ i* i+ i- i#
" " a_ a. a: a, a; a| a/ a\ a* a+ a- a#
" for char in [ '_', '.', ':', ',', ';', '<bar>', '/', '<bslash>', '*', '+', '-', '#' ]
"     execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
"     execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
"     execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
"     execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
" endfor
"" line text-objects
" " -----------------
" " il al
" xnoremap il g_o^
" onoremap il :normal vil<CR>
" xnoremap al $o0
" onoremap al :normal val<CR>
"
" " number text-objects (integer and float)
" " ---------------------------------------
" " in an
" function! VisualNumber()
"     call search('\d\([^0-9\.]\|$\)', 'cW')
"     normal v
"     call search('\(^\|[^0-9\.]\d\)', 'becW')
" endfunction
" xnoremap in :<C-u>call VisualNumber()<CR>
" onoremap in :normal vin<CR>
"
" " buffer text-objects
" " -------------------
" " i% a%
" xnoremap i% :<C-u>let z = @/\|1;/^./kz<CR>G??<CR>:let @/ = z<CR>V'z
" onoremap i% :normal vi%<CR>
" xnoremap a% GoggV
" onoremap a% :normal va%<CR>
"
" " comment text-objects
" " --------------------
" " i? a?
" xnoremap <buffer> i? ?/\*<CR>o/\*\/<CR>
" onoremap <buffer> i? :normal vi?<CR>
" " }}}
